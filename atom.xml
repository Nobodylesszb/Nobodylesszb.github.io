<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Nobodylesszb.github.io</id>
    <title>博</title>
    <updated>2020-03-14T16:25:40.814Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Nobodylesszb.github.io"/>
    <link rel="self" href="https://Nobodylesszb.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://Nobodylesszb.github.io/images/avatar.png</logo>
    <icon>https://Nobodylesszb.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 博</rights>
    <entry>
        <title type="html"><![CDATA[docker部署主从数据库]]></title>
        <id>https://Nobodylesszb.github.io/post/a486-L6HE/</id>
        <link href="https://Nobodylesszb.github.io/post/a486-L6HE/">
        </link>
        <updated>2020-03-14T16:05:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="docker部署主从数据库">docker部署主从数据库</h2>
<h3 id="下载docker">下载docker</h3>
<p>笔者是mac版本的docker，下载官网是<a href="https://hub.docker.com/">官网</a>,请各位自行下载</p>
<h3 id="开启k8s">开启k8s</h3>
<p>笔者在开启k8s的时候总是显示<code>starting</code>但是就是启动不起来。一番查找之后找到了原因，由于众所周知的原因，启动 Kubernetes 所需的镜像往往会下载失败，于是点击 <em>Apply</em> 后，该配置页面的右下角始终显示 <em>Kubernetes is starting</em>，无法正常启动。</p>
<p><a href="https://github.com/maguowei/k8s-docker-desktop-for-mac">Docker Desktop for Mac 开启并使用 Kubernetes</a> 为该问题提供了解决方案。</p>
<p>我们先将该仓库拉取到本地：</p>
<pre><code class="language-bash">git clone git@github.com:maguowei/k8s-docker-desktop-for-mac.git
</code></pre>
<p>然后确认一下 Docker Desktop 自带的 Kubernetes 的版本。点击 Docker 图标，选择 <em>About Docker Desktop</em>，看到如下界面：</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1584201976-image-20200314214514924.png" alt="image-20200314214514924" loading="lazy"></figure>
<p>可以看到 Kubernetes 的版本是 v1.15.5。</p>
<p>我们用下面命令切换 <a href="https://github.com/AliyunContainerService/k8s-for-docker-desktop/tree/v1.15.5">v1.15.5 分支</a> <code>git checkout v1.15.5</code></p>
<p>在 Mac 上执行如下脚本</p>
<pre><code class="language-bash">./load_images.sh
</code></pre>
<p>等待更换完成</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1584193774-image-20200314214933763.png" alt="image-20200314214933763" loading="lazy"></figure>
<p>然后重启docker可以看到已经成功启动</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1584193847-image-20200314215047476.png" alt="image-20200314215047476" loading="lazy"></figure>
<h3 id="创建mysql-3307master">创建mysql-3307（master）</h3>
<p>我们先拉去mysql最近镜像文件<code>docker pull mysql:latest</code></p>
<p>然后在/docker/mysql/mysql-3307下创建配置文件夹，笔者创建了三个文件夹，data：用来存放数据，conf:用来</p>
<p>配置mysql配置，bash:用来存放开启命令</p>
<pre><code class="language-bash"> mkdir -p /docker/mysql/mysql-3308/conf
 mkdir -p /docker/mysql/mysql-3308/mysql-files
 mkdir -p /docker/mysql/mysql-3308/data
 cd /docker/mysql/mysql-3308/conf
</code></pre>
<p>我们先创建配置文件，图中的mysql-3307.cnf</p>
<pre><code class="language-xml">[mysqld]
user=mysql
character-set-server=utf8mb4
default_authentication_plugin=mysql_native_password
[client]
default-character-set=utf8mb4
[mysql]
default-character-set=utf8mb4
[mysqld]
port=3307
</code></pre>
<p><strong>切记</strong>运行mysql命令之前，先将你的配置文件路径放到docker设置中<code>FILE SHARING</code>中，然后重启</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1584194766-image-20200314220605825.png" alt="image-20200314220605825" loading="lazy"></figure>
<p>然后开启mysql</p>
<pre><code class="language-bash">docker run -d -p 3307:3307 --privileged=true -v /docker/mysql/mysql-3307/conf/my-3307.cnf:/etc/mysql/my.cnf -v /docker/mysql/mysql-3307/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql-3307 mysql:latest
</code></pre>
<p>参数说明</p>
<ul>
<li>
<p>-p 3307:3307:端口映射，将本地3307端口映射到mysql3307端口</p>
</li>
<li>
<p>--privileged=true：容器内的root拥有真正root权限，否则容器内root只是外部普通用户权限</p>
</li>
<li>
<p>-v /docker/mysq/mysql-3307/conf/my-3307.cnf:/etc/mysql/my.cnf：映射配置文件</p>
</li>
<li>
<p>-v /docker/mysql/mysql-3307/data:/var/lib/mysql：映射数据目录</p>
</li>
<li>
<p>-e MYSQL_ROOT_PASSWORD=123456 :设置root账户密码123456</p>
</li>
<li>
<p>--name mysql-3307：设置容器名称mysql-3307</p>
</li>
</ul>
<p>这里出现了一个错误，mysql没有启动起来，我们看到是因为/var/lib/mysql-file，查询得知当指定了外部配置文件与外部存储路径时，也需要指定 /var/lib/mysql-files的外部目录，所以在 主机新建/docker/mysql/mysql-3307/mysql-files目录，</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1584193350-image-20200314214230475.png" alt="image-20200314214230475" loading="lazy"></figure>
<p>重新执行新的命令</p>
<pre><code class="language-bash">docker run -d -p 3307:3307 --privileged=true -v /docker/mysql/mysql-3307/conf/my-3307.cnf:/etc/mysql/my.cnf -v /docker/mysql/mysql-3307/data:/var/lib/mysql -v /docker/mysql/mysql-3307/mysql-files:/var/lib/mysql-files/ -e MYSQL_ROOT_PASSWORD=123456 --name mysql-3307 mysql:latest
e95e247dc96d547bf37b8ee388e9d351e196c4e92cee88441f74efd510527962 --镜像
</code></pre>
<p>我们可以用 <code>docker ps</code> 来查看进程,状态显示up，表示已经成功启动，</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1584195715-image-20200314222155737.png" alt="image-20200314222155737" loading="lazy"></figure>
<p>我们在用navicate连接测试一下</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1584195835-image-20200314222355460.png" alt="image-20200314222355460" loading="lazy"></figure>
<h3 id="创建mysql-3307master-2">创建mysql-3307（master）</h3>
<p>和前面的主库差不多，不过从库的配置文件变了</p>
<pre><code class="language-bash"> mkdir -p /docker/mysql/mysql-3308/conf
 mkdir -p /docker/mysql/mysql-3308/mysql-files
 mkdir -p /docker/mysql/mysql-3308/data
cd /docker/mysql/mysql-3308/conf
sudo touch my-3308.cnf
//mysql-3308.cnf
[mysqld]
user = mysql
character-set-server = utf8mb4
default_authentication_plugin = mysql_native_password

[client]
default-character-set = utf8mb4

[mysql]
default-character-set = utf8mb4

[mysqld]
port=3308

docker run -d -p 3308:3308 --privileged=true -v /docker/mysql/mysql-3308/conf/my-3308.cnf:/etc/mysql/my.cnf -v /docker/mysql/mysql-3308/data:/var/lib/mysql -v /docker/mysql/mysql-3308/mysql-files:/var/lib/mysql-files/ -e MYSQL_ROOT_PASSWORD=123456 --name mysql-3308 mysql:latest


</code></pre>
<p>我们使用<code>docker ps</code>来查看时候启动</p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1584197839-image-20200314225719550.png" alt="image-20200314225719550" loading="lazy"></figure>
<h3 id="配置master的slave访问用户">配置master的slave访问用户</h3>
<pre><code class="language-bash">//进入mysql-3307的docker命令行
sudo docker exec -it mysql-1 bash
mysql -uroot -p123456

mysql&gt; use mysql;
mysql&gt; select host, user, plugin from user;
+-----------+------------------+-----------------------+
| host      | user             | plugin                |
+-----------+------------------+-----------------------+
| %         | root             | mysql_native_password |
| localhost | mysql.infoschema | caching_sha2_password |
| localhost | mysql.session    | caching_sha2_password |
| localhost | mysql.sys        | caching_sha2_password |
| localhost | root             | mysql_native_password |
+-----------+------------------+-----------------------+
</code></pre>
<blockquote>
<p>这里有个地方要注意一下 mysql8.0默认的身份验证插件是 caching_sha2_password, 旧版的navicat不支持这种身份验证插件，可以修改为mysql_native_password<br>
在MySQL 5.7中，默认的身份验证插件是 mysql_native_password !<br>
( ALTER USER ‘root’@‘localhost’ IDENTIFIED WITH mysql_native_password BY ‘123456’; )</p>
</blockquote>
<p>由于我们在配置中预先设置了default_authentication_plugin = mysql_native_password<br>
所以默认root的密码加密是mysql_native_password</p>
<pre><code class="language-sql">//创建slave用户
mysql&gt; CREATE USER 'slave_1'@'%' IDENTIFIED BY '123456';
Query OK, 0 rows affected (0.13 sec)
//给新用户授权
mysql&gt; GRANT REPLICATION SLAVE ON *.* TO 'slave_1'@'%';
Query OK, 0 rows affected (0.31 sec)
//刷新权限
mysql&gt; FLUSH PRIVILEGES;
Query OK, 0 rows affected (0.02 sec)
</code></pre>
<h3 id="配置mysql-3307master的-my-3307cnf">配置mysql-3307(master)的 my-3307.cnf</h3>
<p>这边配置一下mysql-3307和mysql-3308的binlog设置 ，因为mysql实际是传输binlog(二进制日志)来达成复制的,具体的同步流程和原理可以百度一下</p>
<p>因为创建docker mysql的时候就把 /docker/mysql/mysql-3307/conf/my-3307.cnf 映射到了 /etc/mysql/my.cnf里,所以直接修改/docker/mysql/mysql-3307/conf/my-3307.cnf 再重启就完事了</p>
<pre><code class="language-bash">[mysqld]
user=mysql
character-set-server=utf8mb4
default_authentication_plugin=mysql_native_password
[client]
default-character-set=utf8mb4
[mysql]
default-character-set=utf8mb4
[mysqld]
port=3307

# 设备编号 不能与其他mysql相同
server-id = 1
# 开启 binlog
log-bin = mysql-bin
# 复制的数据库
binlog-do-db = test_school
# 不复制的数据库
binlog_ignore_db = mysql
# 从复制的格式（mixed,statement,row，默认格式是statement）
binlog-format = mixed
# 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。
expire_logs_days = 7  
</code></pre>
<p>重启一下mysql-3307(master)</p>
<pre><code class="language-sql">sudo docker restart mysql-1
sudo docker exec -it mysql-1 bash
mysql -uroot -p123456
mysql&gt; show master status;
+------------------+----------+--------------+-------------------------------------------------+-------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB                                | Executed_Gtid_Set |
+------------------+----------+--------------+-------------------------------------------------+-------------------+
| mysql-bin.000001 |      155 | test_school  | sys,mysql,information_schema,performance_schema |                   |
+------------------+----------+--------------+-------------------------------------------------+-------------------+
1 row in set (0.00 sec)
</code></pre>
<p>可以看到mysql-3306(master)binlog生效了</p>
<h3 id="配置mysql-3308slave的-mycnf">配置mysql-3308(slave)的 my.cnf</h3>
<p>同理修改mysql-3308(slave)的配置文件</p>
<pre><code class="language-bash">[mysqld]
user = mysql
character-set-server = utf8mb4
default_authentication_plugin = mysql_native_password

[client]
default-character-set = utf8mb4

[mysql]
default-character-set = utf8mb4

[mysqld]
port=3308

bind-address = 0.0.0.0

#skip-name-resolve

# 设备编号 不能与其他mysql相同
server-id = 2
# 开启 binlog 以备Slave作为其它Slave的Master时使用
log-bin = mysql-slave1-bin
# 复制的数据库
binlog-do-db = test_school
# 不复制的数据库
binlog_ignore_db = mysql
# 从复制的格式（mixed,statement,row，默认格式是statement）
binlog-format = mixed
# 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。
expire_logs_days = 7

</code></pre>
<p>配置mysql-3308(slave)的mysql同步信息</p>
<pre><code class="language-bash">sudo docker restart mysql-3308
sudo docker exec -it mysql-2 bash
mysql -uroot -p123456

//修改要同步的master的配置, 用之前在mysql-3308(master)创建的slave_1用户
mysql&gt; CHANGE MASTER TO
    -&gt; MASTER_HOST='*.*.*.*',
    -&gt; MASTER_USER='slave_1',
    -&gt; MASTER_PASSWORD='123456',
    -&gt; MASTER_PORT=33061,
    -&gt; MASTER_LOG_FILE='mysql-bin.000001',
    -&gt; MASTER_LOG_POS=155;
Query OK, 0 rows affected, 2 warnings (0.45 sec)
</code></pre>
<p>MASTER_LOG_FILE 就是master里的File, MASTER_LOG_POS就是master里的Position</p>
<h3 id="关于mster_host的指向问题">关于MSTER_HOST的指向问题</h3>
<p>这里是用docker做的主从复制，必须要是用外网IP才可以连接，内网IP或者localhost都是不行的！ 在docker里面用内网IP连不上另一个docker的mysql，必要要用外网IP，外网IP，外网IP！</p>
<h3 id="查看同步状态">查看同步状态</h3>
<p>先开启 slave</p>
<pre><code class="language-sql">mysql&gt; start slave;
Query OK, 0 rows affected (0.02 sec)

mysql&gt; show slave status 
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: *.*.*.*
                  Master_User: slave_1
                  Master_Port: 33061
                Connect_Retry: 60
              Master_Log_File: mysql-bin.000003
          Read_Master_Log_Pos: 155
               Relay_Log_File: 1675298fc92a-relay-bin.000004
                Relay_Log_Pos: 369
        Relay_Master_Log_File: mysql-bin.000003
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
            ...

1 row in set (0.00 sec)
</code></pre>
<p>看到 Slave_IO_Running, Slave_SQL_Running 都为YES的情况 就是主从复制设置成功了<br>
当然你也可以在主库表中插入一条数据，看看从库是否有同步</p>
<p>这里有可能存在的错误：</p>
<ul>
<li>
<p>网络不通</p>
</li>
<li>
<p>账号密码错误</p>
</li>
<li>
<p>master_log_file 或者 master_log_pos 错误</p>
</li>
<li>
<p>端口未开放（防火墙）</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[消息队列的使用]]></title>
        <id>https://Nobodylesszb.github.io/post/rabbitmq/</id>
        <link href="https://Nobodylesszb.github.io/post/rabbitmq/">
        </link>
        <updated>2020-03-11T07:39:02.000Z</updated>
        <content type="html"><![CDATA[<h3 id="爬虫生产者消费者模型">爬虫生产者消费者模型</h3>
<h4 id="为什么使用rabbitmq">为什么使用rabbitmq</h4>
<p>我们都知道消息队列主要作用就是<code>解耦，异步，削峰</code>，在处理爬虫的时候遇到下列这样的问题，</p>
<ul>
<li>有时候爬取网页时候。总有漏爬的信息。比如一块区域内商家的消息这样，爬虫突然中断，导致漏爬。对于漏爬是不可接受的，因为这是客户要求的，所以就必须先保存商家的id入库，等到真正采集到，再删除</li>
<li>对于突然中断的任务，如果采用之前的方式，是没有消息通知的，</li>
<li>我们可以允许消息多次消费，但是不能允许消息丢失</li>
<li>异步爬取。不必立即爬取信息</li>
</ul>
<p>综合考察，决定采用消息队列做消息容器</p>
<h4 id="如何保证rabbitmq的高可用">如何保证rabbitmq的高可用</h4>
<p>在设计爬虫生产者消费者模型的时候，高可用是必须要保证的，详情请看<a href="https://github.com/Nobodylesszb/ExcellentJava/blob/master/doc/system-design/data-communication/rabbitmq/rabbitmq%E9%AB%98%E5%8F%AF%E7%94%A8.md">rabbitmq高可用</a>)</p>
<p>这是我写的一篇关于rabbitmq如何高可用的文章</p>
<h4 id="如何保证消息不被重复消费">如何保证消息不被重复消费</h4>
<p>虽然在设计爬虫生产者消费者模型的时候对消息的重复性不是那么的关注，但是能不重复消费总是好的</p>
<h4 id="如何保证消息的可靠性传输-比如消息丢失问题">如何保证消息的可靠性传输。比如消息丢失问题</h4>
<p>数据的丢失问题，可能出现在生产者、MQ、消费者中，咱们从 RabbitMQ 和 Kafka 分别来分析一下吧。</p>
<h3 id="rabbitmq">RabbitMQ</h3>
<p>[<img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1583676539-rabbitmq-message-lose.png" alt="rabbitmq-message-lose" loading="lazy">]</p>
<h4 id="生产者弄丢了数据">生产者弄丢了数据</h4>
<p>生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，因为网络问题啥的，都有可能。</p>
<p>此时可以选择用 RabbitMQ 提供的事务功能，就是生产者<strong>发送数据之前</strong>开启 RabbitMQ 事务<code>channel.txSelect</code>，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务<code>channel.txRollback</code>，然后重试发送消息；如果收到了消息，那么可以提交事务<code>channel.txCommit</code>。</p>
<pre><code>// 开启事务
channel.txSelect
try {
    // 这里发送消息
} catch (Exception e) {
    channel.txRollback

    // 这里再次重发这条消息
}

// 提交事务
channel.txCommit
</code></pre>
<p>但是问题是，RabbitMQ 事务机制（同步）一搞，基本上<strong>吞吐量会下来，因为太耗性能</strong>。</p>
<p>所以一般来说，如果你要确保说写 RabbitMQ 的消息别丢，可以开启 <code>confirm</code> 模式，在生产者那里设置开启 <code>confirm</code> 模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个 <code>ack</code> 消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个 <code>nack</code> 接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。</p>
<p>事务机制和 <code>confirm</code> 机制最大的不同在于，<strong>事务机制是同步的</strong>，你提交一个事务之后会<strong>阻塞</strong>在那儿，但是 <code>confirm</code> 机制是<strong>异步</strong>的，你发送个消息之后就可以发送下一个消息，然后那个消息 RabbitMQ 接收了之后会异步回调你的一个接口通知你这个消息接收到了。</p>
<p>所以一般在生产者这块<strong>避免数据丢失</strong>，都是用 <code>confirm</code> 机制的。</p>
<h4 id="rabbitmq-弄丢了数据">RabbitMQ 弄丢了数据</h4>
<p>就是 RabbitMQ 自己弄丢了数据，这个你必须<strong>开启 RabbitMQ 的持久化</strong>，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，<strong>恢复之后会自动读取之前存储的数据</strong>，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，<strong>可能导致少量数据丢失</strong>，但是这个概率较小。</p>
<p>设置持久化有<strong>两个步骤</strong>：</p>
<ul>
<li>创建 queue 的时候将其设置为持久化<br>
这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。</li>
<li>第二个是发送消息的时候将消息的 <code>deliveryMode</code> 设置为 2<br>
就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。</li>
</ul>
<p>必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。</p>
<p>注意，哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。</p>
<p>所以，持久化可以跟生产者那边的 <code>confirm</code> 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 <code>ack</code> 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 <code>ack</code>，你也是可以自己重发的。</p>
<h4 id="消费端弄丢了数据">消费端弄丢了数据</h4>
<p>RabbitMQ 如果丢失了数据，主要是因为你消费的时候，<strong>刚消费到，还没处理，结果进程挂了</strong>，比如重启了，那么就尴尬了，RabbitMQ 认为你都消费了，这数据就丢了。</p>
<p>这个时候得用 RabbitMQ 提供的 <code>ack</code> 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 <code>ack</code>，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 <code>ack</code> 一把。这样的话，如果你还没处理完，不就没有 <code>ack</code> 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。</p>
<p>[<img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1583676540-rabbitmq-message-lose-solution.png" alt="rabbitmq-message-lose-solution" loading="lazy">]</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://Nobodylesszb.github.io/post/hello-gridea/</id>
        <link href="https://Nobodylesszb.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>