<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Nobodylesszb.github.io</id>
    <title>博</title>
    <updated>2020-10-12T02:03:16.582Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Nobodylesszb.github.io"/>
    <link rel="self" href="https://Nobodylesszb.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://Nobodylesszb.github.io/images/avatar.png</logo>
    <icon>https://Nobodylesszb.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 博</rights>
    <entry>
        <title type="html"><![CDATA[Lombok子类如何使用@Builder]]></title>
        <id>https://Nobodylesszb.github.io/post/6DXi-P3LV/</id>
        <link href="https://Nobodylesszb.github.io/post/6DXi-P3LV/">
        </link>
        <updated>2020-10-12T02:01:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-前言">一、前言</h2>
<p>业务开发中，子类父类还算是经常用到，Lombok 的 <code>@builder</code> 提供的链式调用帮助我们更轻松的创建对象。但是实验后却发现子类的 <code>@Builder</code> 是不会包含父类的属性。</p>
<p>假设存在父类 <code>A</code>：</p>
<pre><code class="language-java">@Data
@Builder
public class A {
    private String aName;

    private String aAge;
}
</code></pre>
<p>存在子类 <code>B</code>：</p>
<pre><code class="language-java">@Builder
@Data
@EqualsAndHashCode(callSuper = true)
public class B extends A {
    private String bName;

    private String bAge;
}
</code></pre>
<p>使用 <code>builder</code> 进行初始化时，类 A 可以正常创建，类 B 仅可以初始化自己的属性，父类属性无法初始化。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1602467788-20200829214450.png" alt="img" loading="lazy"></figure>
<h2 id="二-解决构造方法">二、解决：构造方法</h2>
<p>查阅网络后，一种解决方法是利用构造方法：</p>
<ol>
<li>父类生成全参构造方法</li>
<li>子类手动声明全参构造方法</li>
<li>将子类 <code>@builder</code> 注解移动全参构造方法上，并设置 <code>builderMethodName</code></li>
</ol>
<pre><code class="language-java">@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class A {
    private String aName;

    private String aAge;
}
@Data
@EqualsAndHashCode(callSuper = true)
@ToString(callSuper = true)
public class B extends A {
    private String bName;

    private String bAge;

    @Builder(builderMethodName = &quot;childBuilder&quot;)
    public B(String aName, String aAge, String bName, String bAge) {
        super(aName, aAge);
        this.bName = bName;
        this.bAge = bAge;
    }
}
</code></pre>
<p>修改 Main 方法如下：</p>
<pre><code class="language-java">public class BuilderMain {
    public static void main(String[] args) {
        A xxx = A.builder()
                .aName(&quot;aa&quot;)
                .aAge(&quot;111&quot;)
                .build();
        B yyy = B.childBuilder()
                .aName(&quot;aa&quot;)
                .aAge(&quot;111&quot;)
                .bName(&quot;bb&quot;)
                .bAge(&quot;222&quot;)
                .build();

        System.out.println(xxx);
        System.out.println(yyy);
    }
}
</code></pre>
<p>代码运行后，能得到正确结果：</p>
<pre><code>A(aName=aa, aAge=111)
&lt;!-- B(super=A(aName=aa, aAge=111), bName=bb, bAge=222) --&gt;
</code></pre>
<p>但是这种方式弊端也很明显：</p>
<ol>
<li>子类调用父类的全参构造，当父类参数数量、顺序调整时，子类也需要同步调整。</li>
<li>如果父类参数过多，构造方法十分不优雅。</li>
</ol>
<h2 id="三-解决superbuilder">三、解决：SuperBuilder</h2>
<p>Lombok 自 <code>v1.18.2</code> 开始，为了解决这个问题，引入了 <code>@SuperBuilder</code> 注解，使用该注解，就可以很容易解决这个问题。</p>
<p>修改代码如下：</p>
<pre><code class="language-java">@Data
@SuperBuilder
public class A {
    private String aName;

    private String aAge;
}
@SuperBuilder
@Data
@EqualsAndHashCode(callSuper = true)
@ToString(callSuper = true)
public class B extends A {
    private String bName;

    private String bAge;
}
</code></pre>
<p>Main 方法保持不变，代码运行后，能得到正确结果：</p>
<pre><code class="language-java">A(aName=xxx, aAge=111)
B(super=A(aName=xxx, aAge=111), bName=yyy, bAge=222)
</code></pre>
<p>另外自 <code>v1.18.4</code> 也给 SuperBuilder 引入了<code>toBuilder</code> 参数，可以很方便的进行<strong>浅拷贝</strong>对象，效率虽然比手动 builder 慢一点，但也算是挺快的。</p>
<pre><code class="language-java">@Data
@SuperBuilder(toBuilder = true)
public class A {
    private String aName;

    private String aAge;
}
</code></pre>
<p>给 B 加入属性 C，测试对象拷贝：</p>
<pre><code class="language-java">@SuperBuilder(toBuilder = true)
@Data
@EqualsAndHashCode(callSuper = true)
@ToString(callSuper = true)
public class B extends A {
    private String bName;

    private String bAge;

    private C c;
}
@AllArgsConstructor
public class C {
    private String name;
}
</code></pre>
<p>输出结果如下：</p>
<pre><code class="language-java">public class BuilderMain {
    public static void main(String[] args) {
        B b = B.builder()
                .aName(&quot;xxx&quot;)
                .aAge(&quot;111&quot;)
                .bName(&quot;yyy&quot;)
                .bAge(&quot;222&quot;)
                .c(new C(&quot;zhangsan&quot;))
                .build();

        System.out.println(b);
        System.out.println(b.toBuilder().build());
    }
}
B(super=A(aName=xxx, aAge=111), bName=yyy, bAge=222, c=com.github.jitwxs.demo.builder.C@52cc8049)
B(super=A(aName=xxx, aAge=111), bName=yyy, bAge=222, c=com.github.jitwxs.demo.builder.C@52cc8049)
</code></pre>
<h2 id="四-彩蛋">四、彩蛋</h2>
<p>由于 <code>@SuperBuilder</code> 刚引入不久，所以还是有一些 BUG 的，比如当你的 SpringBoot 版本为 <code>2.2.3.RELEASE</code> 时，或者你的 Lombok 版本低于 <code>v1.18.12</code> 时，使用上文的例子，你就会发现竟然无法通过编译。</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1602467788-20200829221256.png" alt="img" loading="lazy"></figure>
<p>实际的原因是不支持用 <code>B</code> 来命名类，简直是吐出一口老血，好在升级到 <code>v1.18.12</code> 版本后就修复了这个问题，可能这就是给不规范命名的人埋的坑吧，哈哈。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[kong/konga之docker部署]]></title>
        <id>https://Nobodylesszb.github.io/post/Uhr6PBQSr/</id>
        <link href="https://Nobodylesszb.github.io/post/Uhr6PBQSr/">
        </link>
        <updated>2020-07-11T02:34:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-前言">1. 前言</h2>
<p>最近项目有用到kong来做网关，所以来本机安装以下</p>
<h2 id="2-kong支持的环境">2. Kong支持的环境</h2>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1594395050-webp-20200710233050613.jpg" alt="img" loading="lazy"></figure>
<p>image.png</p>
<p>从上图来看Kong对Linux、MacOS、容器、云 支持的还是比较全面的。</p>
<p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fkonghq.com%2F">官网地址</a><br>
<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FKong%2Fkong">github地址</a></p>
<h2 id="3-安装kong">3. 安装Kong</h2>
<p>你的机器中必须有Docker环境，这个是前提。。Kong 安装有两种方式一种是没有数据库依赖的DB-less 模式，另一种是with a Database 模式。我们这里使用第二种带Database的模式，因为这种模式功能更全。</p>
<h3 id="31-构建kong的容器网络">3.1 构建Kong的容器网络</h3>
<p>首先我们创建一个Docker自定义网络，以允许容器相互发现和通信。在下面的创建命令中<code>kong-net</code>是我们创建的Docker网络名称。</p>
<pre><code class="language-docker">docker network create kong-net
</code></pre>
<h3 id="32-搭建数据库环境">3.2 搭建数据库环境</h3>
<p>Kong 目前使用Cassandra(Facebook开源的分布式的NoSQL数据库) 或者PostgreSql,你可以执行以下命令中的一个来选择你的Database。请注意定义网络 <code>--network=kong-net</code> 。</p>
<ul>
<li>Cassandra容器：</li>
</ul>
<pre><code class="language-undefined">docker run -d --name kong-database \
--network=kong-net \
-p 9042:9042 \
cassandra:3
</code></pre>
<ul>
<li>PostgreSQL容器：</li>
</ul>
<pre><code class="language-bash">docker run -d --name kong-database \
               --network=kong-net \
               -p 5432:5432 \
               -e &quot;POSTGRES_USER=kong&quot; \
               -e &quot;POSTGRES_DB=kong&quot; \
               -e &quot;POSTGRES_PASSWORD=kong&quot; \
               postgres:9.6

</code></pre>
<p>这里有个小问题。如果你使用的是PostgreSQL，想挂载卷持久化数据到宿主机。通过 <code>-v</code> 命令是不好用的。这里推荐你使用 <code>docker volume create</code> 命令来创建一个挂载。</p>
<pre><code class="language-undefined">docker volume create kong-volume
</code></pre>
<p>然后上面的PostgreSQL就可以通过<code>- v kong-volume:/var/lib/postgresql/data</code> 进行挂载了。</p>
<pre><code class="language-kotlin">docker run -d --name kong-database \
--network=kong-net \
-p 5432:5432 \
-v kong-volume:/var/lib/postgresql/data \
-e &quot;POSTGRES_USER=kong&quot; \
-e &quot;POSTGRES_DB=kong&quot; \
-e &quot;POSTGRES_PASSWORD=kong&quot; \
postgres:9.6
</code></pre>
<h3 id="33-初始化或者迁移数据库">3.3 初始化或者迁移数据库</h3>
<p>我们使用<code>docker run --rm</code>来初始化数据库，该命令执行后会退出容器而保留内部的数据卷（volume）。</p>
<pre><code class="language-bash">docker run --rm \
     --network=kong-net \
     -e &quot;KONG_DATABASE=postgres&quot; \
     -e &quot;KONG_PG_HOST=kong-database&quot; \
     -e &quot;KONG_PG_USER=kong&quot; \
     -e &quot;KONG_PG_PASSWORD=kong&quot; \
     -e &quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&quot; \
     kong:latest kong migrations bootstrap
</code></pre>
<p>这个命令我们还是要注意的，一定要跟你声明的网络，数据库类型、host名称一致。同时注意Kong的版本号，本文是在<code>Kong 1.4.x</code> 版本下完成的。</p>
<p>出现以下命令则完成</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1594395292-image-20200710233451663.png" alt="image-20200710233451663" loading="lazy"></figure>
<p>我们可以看到数据库中已经有表出现了</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1594395338-image-20200710233537744.png" alt="image-20200710233537744" loading="lazy"></figure>
<h3 id="34-启动kong容器">3.4 启动Kong容器</h3>
<p>3.3步骤完成初始化或者迁移数据库后，我们就可以启动一个连接到数据库容器的Kong容器，请务必保证你的数据库容器启动状态，同时检查所有的环境参数 <code>-e</code> 是否是你定义的环境。</p>
<pre><code class="language-bash">docker run -d --name kong \
 --network=kong-net \
 -e &quot;KONG_DATABASE=postgres&quot; \
 -e &quot;KONG_PG_HOST=kong-database&quot; \
  -e &quot;KONG_PG_USER=kong&quot; \
  -e &quot;KONG_PG_PASSWORD=kong&quot; \
 -e &quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&quot; \
 -e &quot;KONG_PROXY_ACCESS_LOG=/dev/stdout&quot; \
 -e &quot;KONG_ADMIN_ACCESS_LOG=/dev/stdout&quot; \
 -e &quot;KONG_PROXY_ERROR_LOG=/dev/stderr&quot; \
 -e &quot;KONG_ADMIN_ERROR_LOG=/dev/stderr&quot; \
 -e &quot;KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl&quot; \
 -p 8000:8000 \
 -p 8443:8443 \
 -p 8001:8001 \
 -p 8444:8444 \
 kong:latest
</code></pre>
<h3 id="35-验证">3.5 验证</h3>
<p>可通过 <code>curl -i &lt;wiz_tmp_plugin_tag id=&quot;wizKMHighlighterSpan_t_t&quot; style=&quot;color: rgb(0, 0, 0); cursor: pointer; border-bottom-width: 1px; border-bottom-color: rgb(0, 0, 204); border-bottom-style: dashed; background-color: rgb(234, 188, 244);&quot;&gt;http&lt;/wiz_tmp_plugin_tag&gt;://localhost:8001/</code> 或者浏览器调用 <code>http://localhost:8001/</code> 来验证Kong Admin 是否联通 。</p>
<h2 id="4-安装kong-管理ui">4. 安装Kong 管理UI</h2>
<p>Kong 企业版提供了管理UI，开源版本是没有的。但是有很多的开源的管理 UI ，其中比较好用的是Konga。项目地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fpantsel%2Fkonga">https://github.com/pantsel/konga</a></p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1594394999-webp-20200710232958808.jpg" alt="img" loading="lazy"></figure>
<h3 id="41-konga-特性">4.1 Konga 特性</h3>
<p>Konga 主要是用 AngularJS 写的，运行于nodejs服务端。具有以下特性：</p>
<ul>
<li>管理所有Kong Admin API对象。</li>
<li>支持从远程源（数据库，文件，API等）导入使用者。</li>
<li>管理多个Kong节点。使用快照备份，还原和迁移Kong节点。</li>
<li>使用运行状况检查监视节点和API状态。</li>
<li>支持电子邮件和闲置通知。</li>
<li>支持多用户。</li>
<li>易于数据库集成（MySQL，postgresSQL，MongoDB，SQL Server）。</li>
</ul>
<h3 id="42-docker安装konga">4.2 docker安装Konga</h3>
<p>我们今天通过Docker来安装Konga。安装步骤同样遵循配置数据库，初始化数据库，启动容器的流程。</p>
<h4 id="421-konga数据库容器">4.2.1 Konga数据库容器</h4>
<p>上面在4.1特性介绍中我们介绍了Konga支持的数据库类型。这里我们依然使用PostgreSQL。请注意我新定义了挂载卷<code>konga-postgresql</code> 。</p>
<pre><code class="language-undefined"> docker volume create konga-postgresql
</code></pre>
<pre><code class="language-kotlin">docker run -d --name konga-database \
--network=kong-net \
-p 5431:5432 \
-v konga-postgresql:/var/lib/postgresql/data \
-e &quot;POSTGRES_USER=kong&quot; \
-e &quot;POSTGRES_DB=konga&quot; \
-e &quot;POSTGRES_PASSWORD=kong&quot; \
postgres:9.6
</code></pre>
<h3 id="422-初始化konga数据库">4.2.2 初始化Konga数据库</h3>
<p>初始化 PostgreSQL 数据库。</p>
<pre><code>docker run --rm  --network=kong-net  pantsel/konga -c prepare -a postgres -u postgresql://kong:kong@konga-database:5432/konga_db
</code></pre>
<p>执行命令</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1594433834-image-20200711101712846.png" alt="image-20200711101712846" loading="lazy"></figure>
<p>然后看我们本地端口5431postgresql中查看库</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1594433882-image-20200711101802174.png" alt="image-20200711101802174" loading="lazy"></figure>
<p>相关命令解读：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>默认</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>执行的命令，这里我们执行的是prepare</td>
<td>-</td>
</tr>
<tr>
<td>-a</td>
<td>adapter 简写 ，可以是postgres 或者mysql</td>
<td>-</td>
</tr>
<tr>
<td>-u</td>
<td>db url 数据库连接全称</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>到此Konga的数据库环境就搞定了。</p>
<h3 id="423-环境参数">4.2.3 环境参数</h3>
<p>Konga 还有一些可配置的环境参数：</p>
<table>
<thead>
<tr>
<th>VAR</th>
<th>DESCRIPTION</th>
<th>VALUES</th>
<th>DEFAULT</th>
</tr>
</thead>
<tbody>
<tr>
<td>HOST</td>
<td>The IP address that will be bind by Konga's server</td>
<td>-</td>
<td>'0.0.0.0'</td>
</tr>
<tr>
<td>PORT</td>
<td>The port that will be used by Konga's server</td>
<td>-</td>
<td>1337</td>
</tr>
<tr>
<td>NODE_ENV</td>
<td>The environment</td>
<td><code>production</code>,<code>development</code></td>
<td><code>development</code></td>
</tr>
<tr>
<td>SSL_KEY_PATH</td>
<td>If you want to use SSL, this will be the absolute path to the .key file. Both <code>SSL_KEY_PATH</code> &amp; <code>SSL_CRT_PATH</code> must be set.</td>
<td>-</td>
<td>null</td>
</tr>
<tr>
<td>SSL_CRT_PATH</td>
<td>If you want to use SSL, this will be the absolute path to the .crt file. Both <code>SSL_KEY_PATH</code> &amp; <code>SSL_CRT_PATH</code> must be set.</td>
<td>-</td>
<td>null</td>
</tr>
<tr>
<td>KONGA_HOOK_TIMEOUT</td>
<td>The time in ms that Konga will wait for startup tasks to finish before exiting the process.</td>
<td>-</td>
<td>60000</td>
</tr>
<tr>
<td>DB_ADAPTER</td>
<td>The database that Konga will use. If not set, the localDisk db will be used.</td>
<td><code>mongo</code>,<code>mysql</code>,<code>postgres</code></td>
<td>-</td>
</tr>
<tr>
<td>DB_URI</td>
<td>The full db connection string. Depends on <code>DB_ADAPTER</code>. If this is set, no other DB related var is needed.</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>DB_HOST</td>
<td>If <code>DB_URI</code> is not specified, this is the database host. Depends on <code>DB_ADAPTER</code>.</td>
<td>-</td>
<td>localhost</td>
</tr>
<tr>
<td>DB_PORT</td>
<td>If <code>DB_URI</code> is not specified, this is the database port. Depends on <code>DB_ADAPTER</code>.</td>
<td>-</td>
<td>DB default.</td>
</tr>
<tr>
<td>DB_USER</td>
<td>If <code>DB_URI</code> is not specified, this is the database user. Depends on <code>DB_ADAPTER</code>.</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>DB_PASSWORD</td>
<td>If <code>DB_URI</code> is not specified, this is the database user's password. Depends on <code>DB_ADAPTER</code>.</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>DB_DATABASE</td>
<td>If <code>DB_URI</code> is not specified, this is the name of Konga's db. Depends on <code>DB_ADAPTER</code>.</td>
<td>-</td>
<td><code>konga_database</code></td>
</tr>
<tr>
<td>DB_PG_SCHEMA</td>
<td>If using postgres as a database, this is the schema that will be used.</td>
<td>-</td>
<td><code>public</code></td>
</tr>
<tr>
<td>KONGA_LOG_LEVEL</td>
<td>The logging level</td>
<td><code>silly</code>,<code>debug</code>,<code>info</code>,<code>warn</code>,<code>error</code></td>
<td><code>debug</code> on dev environment &amp; <code>warn</code> on prod.</td>
</tr>
<tr>
<td>TOKEN_SECRET</td>
<td>The secret that will be used to sign JWT tokens issued by Konga</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>NO_AUTH</td>
<td>Run Konga without Authentication</td>
<td>true/false</td>
<td>-</td>
</tr>
<tr>
<td>BASE_URL</td>
<td>Define a base URL or relative path that Konga will be loaded from. Ex: <a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.example.com%2Fkonga">www.example.com/konga</a></td>
<td></td>
<td>-</td>
</tr>
<tr>
<td>KONGA_SEED_USER_DATA_SOURCE_FILE</td>
<td>Seed default users on first run. <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fpantsel%2Fkonga%2Fblob%2Fmaster%2Fdocs%2FSEED_DEFAULT_DATA.md">Docs</a>.</td>
<td></td>
<td>-</td>
</tr>
<tr>
<td>KONGA_SEED_KONG_NODE_DATA_SOURCE_FILE</td>
<td>Seed default Kong Admin API connections on first run <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fpantsel%2Fkonga%2Fblob%2Fmaster%2Fdocs%2FSEED_DEFAULT_DATA.md">Docs</a></td>
<td></td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="424-启动konga">4.2.4 启动Konga</h3>
<p>通过以下命令就可以启动Konga容器了</p>
<pre><code class="language-bash">docker run -d -p 1337:1337  \
               --network kong-net  \
               -e &quot;DB_ADAPTER=postgres&quot;  \
               -e &quot;DB_URI=postgres://kong:kong@konga-database:5432/konga_db&quot;  \
               -e &quot;NODE_ENV=production&quot;  \
               -e &quot;DB_PASSWORD=konga&quot; \
               --name konga \
               pantsel/konga
</code></pre>
<p>运行完后，如果成功可以通过<code>http://localhost:1337</code> 链接到控制台。通过注册后进入，然后在dashboard面板里面添加Kong的管理Api路径<code>http://yourdomain</code> 。这里添加docker别名 <code>http://kong:8001</code> 。</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1594434815-image-20200711103334311.png" alt="image-20200711103334311" loading="lazy"></figure>
<h3 id="注意">注意</h3>
<p>​	在用konga连接kong的时候，如果使用本地地址即：127.0.0.1：8001连接的时候。始终会报错无法链接，经查询<a href="https://github.com/pantsel/konga/issues/157">GithubIssue</a>得知：</p>
<blockquote>
<p>I my case the problem was different. I was using docker to run Kong, Konga and Postgresql on a separate network on docker called <code>kong-net</code>. Each of these docker containers exposed ports on host machine's <code>127.0.0.1</code>. I could access Kong's service page at http://127.0.0.1:8001/. However, putting this URL in Konga's GUI configuration page yielded the &quot;Oops..&quot; error.I then realized a foolish mistake. From the container's perspective <code>127.0.0.1</code> would point to itself! So I ran <code>sudo docker network inspect kong-net</code> to get the IP of the Kong server on <code>kong-net</code> network and used that in Konga's config page.</p>
</blockquote>
<p>所以使用<code>sudo docker network inspect kong-net</code>命令来查看kong的ip</p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1594440319-image-20200711120518087.png" alt="image-20200711120518087" loading="lazy"></figure>
<p>我们可以看到kong的ip为172.18.0.3,再去连接</p>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1594440380-image-20200711120619887.png" alt="image-20200711120619887" loading="lazy"></figure>
<p>就可以进入到网关界面</p>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1594440415-image-20200711120653907.png" alt="image-20200711120653907" loading="lazy"></figure>
<h2 id="本文参考">本文参考</h2>
<ul>
<li><a href="https://www.yisu.com/zixun/6962.html">docker容器搭建kong-dashboard或konga</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java无法连接7.7.1版本elasticsearch]]></title>
        <id>https://Nobodylesszb.github.io/post/VR3BsE0kU/</id>
        <link href="https://Nobodylesszb.github.io/post/VR3BsE0kU/">
        </link>
        <updated>2020-06-18T06:39:02.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>最近在学习es的过程中遇到一些问题，特来记录一下</p>
</blockquote>
<h2 id="前序">前序</h2>
<p>因为笔者是mac笔记本，所以直接用brew安装的<code>elasticsearch</code>,是7.7.1版本</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1592460685-image-20200618141122805.png" alt="image-20200618141122805" loading="lazy"></figure>
<p>查看es的<a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html">官网文档</a>可以看到7.7.1版本的maven依赖，官方推荐使用<code>high-level</code>的版本</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;
    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;
    &lt;version&gt;7.7.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>然后我们再看他的初始化配置</p>
<pre><code class="language-java">RestHighLevelClient client = new RestHighLevelClient(
        RestClient.builder(
                new HttpHost(&quot;localhost&quot;, 9200, &quot;http&quot;),
                new HttpHost(&quot;localhost&quot;, 9201, &quot;http&quot;)));
</code></pre>
<p>我们在java项目中写一个配置类，如下</p>
<pre><code class="language-java">@Configuration
public class GulimallElasticSearchConfig {

    @Bean
    public RestHighLevelClient esRestClient(){
        RestHighLevelClient client = new RestHighLevelClient(
                RestClient.builder(new HttpHost(&quot;localhost&quot;, 9200, &quot;http&quot;)));
        return  client;
    }
}
</code></pre>
<p>然后基本的yml配置</p>
<pre><code class="language-yml">server:
  port:9001


spring:
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
  application:
    name: search
</code></pre>
<p>然后启动</p>
<pre><code class="language-java">org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'esRestClient' defined in class path resource [com/atguigu/gulimall/search/config/GulimallElasticSearchConfig.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.elasticsearch.client.RestHighLevelClient]: Factory method 'esRestClient' threw exception; nested exception is java.lang.NoSuchFieldError: IGNORE_DEPRECATIONS
	
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1592461149-image-20200618141907712.png" alt="image-20200618141907712" loading="lazy"></figure>
<p>发现其报错了</p>
<p>其中最主要的一句报错就是</p>
<p><strong>org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'esRestClient' defined in class path resource [com/atguigu/gulimall/search/config/GulimallElasticSearchConfig.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.elasticsearch.client.RestHighLevelClient]: Factory method 'esRestClient' threw exception; nested exception is java.lang.NoSuchFieldError: IGNORE_DEPRECATIONS</strong></p>
<h2 id="解决">解决</h2>
<p>笔者查看了一些stackoverflow,<a href="https://stackoverflow.com/questions/62338588/spring-boot-with-elastic-search-causing-java-lang-nosuchfielderror-ignore-depre">具体网址</a></p>
<p>不仅需要加这个依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;
    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;
    &lt;version&gt;7.7.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>仍然需要加这两个依赖</p>
<pre><code class="language-xml">		&lt;dependency&gt;
            &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;
            &lt;artifactId&gt;elasticsearch-rest-client&lt;/artifactId&gt;
            &lt;version&gt;7.7.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt;
            &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt;
            &lt;version&gt;7.7.1&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>然后重新clean，install，重启</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1592462290-image-20200618143808157.png" alt="image-20200618143808157" loading="lazy"></figure>
<p>可见已经启动</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Cloud Eureka：服务注册与发现]]></title>
        <id>https://Nobodylesszb.github.io/post/uGJMQ57dS/</id>
        <link href="https://Nobodylesszb.github.io/post/uGJMQ57dS/">
        </link>
        <updated>2020-04-07T14:58:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="spring-cloud-eureka服务注册与发现">Spring Cloud Eureka：服务注册与发现</h1>
<h2 id="摘要">摘要</h2>
<p>Spring Cloud Eureka是Spring Cloud Netflix 子项目的核心组件之一，主要用于微服务架构中的服务治理。 本文将对搭建Eureka注册中心，搭建Eureka客户端，搭建Eureka集群及给Eureka注册中心添加登录认证进行介绍。</p>
<h2 id=""></h2>
<h2 id="eureka简介">Eureka简介</h2>
<p>在微服务架构中往往会有一个注册中心，每个微服务都会向注册中心去注册自己的地址及端口信息，注册中心维护着服务名称与服务实例的对应关系。每个微服务都会定时从注册中心获取服务列表，同时汇报自己的运行情况，这样当有的服务需要调用其他服务时，就可以从自己获取到的服务列表中获取实例地址进行调用，Eureka实现了这套服务注册与发现机制。</p>
<h3 id="搭建eureka注册中心">搭建Eureka注册中心</h3>
<ul>
<li>填写应用信息</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1586261155-image-20200407200555211.png" alt="image-20200407200555211" loading="lazy"></figure>
<ul>
<li>这里我们选择springcloud组件进行创建</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1586261174-image-20200407200614074.png" alt="image-20200407200614074" loading="lazy"></figure>
<ul>
<li>在启动类上添加@EnableEurekaServer注解来启用Euerka注册中心功能</li>
</ul>
<pre><code class="language-java">@EnableEurekaServer
@SpringBootApplication
public class EurekaServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }

}

</code></pre>
<ul>
<li>在配置文件application.yml中添加Eureka注册中心的配置,这里一共配置三个注册中心。端口分别为8761,8762,8763，两两相互注册</li>
</ul>
<pre><code class="language-yml">//application.yml文件
spring:
  profiles:
    active: eureka1
    
//application-eureka1.yml
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8762/eureka/,http://localhost:8763/eureka/
  register-with-eureka: false
  fetchRegistry: false
  server:
    enable-self-preservation: false
spring:
  application:
    name: eureka
server:
  port: 8761
</code></pre>
<p>其中：</p>
<ul>
<li>server.port: 指明了应用启动的端口号</li>
<li>eureka.instance.hostname: 应用的主机名称</li>
<li>eureka.client.registerWithEureka: 值为<code>false</code>意味着自身仅作为服务器，不作为客户端</li>
<li>eureka.client.fetchRegistry: 值为<code>false</code>意味着无需注册自身</li>
<li>eureka.client.serviceUrl.defaultZone: 指明了应用的URL</li>
</ul>
<p>常用的Eureka服务配置</p>
<pre><code class="language-yml">eureka:
  client: #eureka客户端配置
    register-with-eureka: true #是否将自己注册到eureka服务端上去
    fetch-registry: true #是否获取eureka服务端上注册的服务列表
    service-url:
      defaultZone: http://localhost:8001/eureka/ # 指定注册中心地址
    enabled: true # 启用eureka客户端
    registry-fetch-interval-seconds: 30 #定义去eureka服务端获取服务列表的时间间隔
  instance: #eureka客户端实例配置
    lease-renewal-interval-in-seconds: 30 #定义服务多久去注册中心续约
    lease-expiration-duration-in-seconds: 90 #定义服务多久不去续约认为服务失效
    metadata-map:
      zone: jiangsu #所在区域
    hostname: localhost #服务主机名称
    prefer-ip-address: false #是否优先使用ip来作为主机名
  server: #eureka服务端配置
    enable-self-preservation: false #关闭eureka服务端的保护机制
</code></pre>
<p>然后依次启动服务</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1586270877-image-20200407224757214.png" alt="image-20200407224757214" loading="lazy"></figure>
<p>源码在<a href="https://github.com/Nobodylesszb/springcloud-guider/tree/master/eureka-server">链接</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker部署主从数据库]]></title>
        <id>https://Nobodylesszb.github.io/post/a486-L6HE/</id>
        <link href="https://Nobodylesszb.github.io/post/a486-L6HE/">
        </link>
        <updated>2020-03-14T16:05:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="下载docker">下载docker</h3>
<p>笔者是mac版本的docker，下载官网是<a href="https://hub.docker.com/">官网</a>,请各位自行下载</p>
<h3 id="开启k8s">开启k8s</h3>
<p>笔者在开启k8s的时候总是显示<code>starting</code>但是就是启动不起来。一番查找之后找到了原因，由于众所周知的原因，启动 Kubernetes 所需的镜像往往会下载失败，于是点击 <em>Apply</em> 后，该配置页面的右下角始终显示 <em>Kubernetes is starting</em>，无法正常启动。</p>
<p><a href="https://github.com/maguowei/k8s-docker-desktop-for-mac">Docker Desktop for Mac 开启并使用 Kubernetes</a> 为该问题提供了解决方案。</p>
<p>我们先将该仓库拉取到本地：</p>
<pre><code class="language-bash">git clone git@github.com:maguowei/k8s-docker-desktop-for-mac.git
</code></pre>
<p>然后确认一下 Docker Desktop 自带的 Kubernetes 的版本。点击 Docker 图标，选择 <em>About Docker Desktop</em>，看到如下界面：</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1584201976-image-20200314214514924.png" alt="image-20200314214514924" loading="lazy"></figure>
<p>可以看到 Kubernetes 的版本是 v1.15.5。</p>
<p>我们用下面命令切换 <a href="https://github.com/AliyunContainerService/k8s-for-docker-desktop/tree/v1.15.5">v1.15.5 分支</a> <code>git checkout v1.15.5</code></p>
<p>在 Mac 上执行如下脚本</p>
<pre><code class="language-bash">./load_images.sh
</code></pre>
<p>等待更换完成</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1584193774-image-20200314214933763.png" alt="image-20200314214933763" loading="lazy"></figure>
<p>然后重启docker可以看到已经成功启动</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1584193847-image-20200314215047476.png" alt="image-20200314215047476" loading="lazy"></figure>
<h3 id="创建mysql-3307master">创建mysql-3307（master）</h3>
<p>我们先拉去mysql最近镜像文件<code>docker pull mysql:latest</code></p>
<p>然后在/docker/mysql/mysql-3307下创建配置文件夹，笔者创建了三个文件夹，data：用来存放数据，conf:用来配置mysql配置，bash:用来存放开启命令</p>
<pre><code class="language-bash"> mkdir -p /docker/mysql/mysql-3308/conf
 mkdir -p /docker/mysql/mysql-3308/mysql-files
 mkdir -p /docker/mysql/mysql-3308/data
 cd /docker/mysql/mysql-3308/conf
</code></pre>
<p>我们先创建配置文件，图中的mysql-3307.cnf</p>
<pre><code class="language-xml">[mysqld]
user=mysql
character-set-server=utf8mb4
default_authentication_plugin=mysql_native_password
[client]
default-character-set=utf8mb4
[mysql]
default-character-set=utf8mb4
[mysqld]
port=3307
</code></pre>
<p><strong>切记</strong>运行mysql命令之前，先将你的配置文件路径放到docker设置中<code>FILE SHARING</code>中，然后重启</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1584194766-image-20200314220605825.png" alt="image-20200314220605825" loading="lazy"></figure>
<p>然后开启mysql</p>
<pre><code class="language-bash">docker run -d -p 3307:3307 --privileged=true -v /docker/mysql/mysql-3307/conf/my-3307.cnf:/etc/mysql/my.cnf -v /docker/mysql/mysql-3307/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql-3307 mysql:latest
</code></pre>
<p>参数说明</p>
<ul>
<li>
<p>-p 3307:3307:端口映射，将本地3307端口映射到mysql3307端口</p>
</li>
<li>
<p>--privileged=true：容器内的root拥有真正root权限，否则容器内root只是外部普通用户权限</p>
</li>
<li>
<p>-v /docker/mysq/mysql-3307/conf/my-3307.cnf:/etc/mysql/my.cnf：映射配置文件</p>
</li>
<li>
<p>-v /docker/mysql/mysql-3307/data:/var/lib/mysql：映射数据目录</p>
</li>
<li>
<p>-e MYSQL_ROOT_PASSWORD=123456 :设置root账户密码123456</p>
</li>
<li>
<p>--name mysql-3307：设置容器名称mysql-3307</p>
</li>
</ul>
<p>这里出现了一个错误，mysql没有启动起来，我们看到是因为/var/lib/mysql-file，查询得知当指定了外部配置文件与外部存储路径时，也需要指定 /var/lib/mysql-files的外部目录，所以在 主机新建/docker/mysql/mysql-3307/mysql-files目录，</p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1584193350-image-20200314214230475.png" alt="image-20200314214230475" loading="lazy"></figure>
<p>重新执行新的命令</p>
<pre><code class="language-bash">docker run -d -p 3307:3307 --privileged=true -v /docker/mysql/mysql-3307/conf/my-3307.cnf:/etc/mysql/my.cnf -v /docker/mysql/mysql-3307/data:/var/lib/mysql -v /docker/mysql/mysql-3307/mysql-files:/var/lib/mysql-files/ -e MYSQL_ROOT_PASSWORD=123456 --name mysql-3307 mysql:latest
e95e247dc96d547bf37b8ee388e9d351e196c4e92cee88441f74efd510527962 --镜像
</code></pre>
<p>我们可以用 <code>docker ps</code> 来查看进程,状态显示up，表示已经成功启动，</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1584195715-image-20200314222155737.png" alt="image-20200314222155737" loading="lazy"></figure>
<p>我们在用navicate连接测试一下</p>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1584195835-image-20200314222355460.png" alt="image-20200314222355460" loading="lazy"></figure>
<h3 id="创建mysql-3308slave">创建mysql-3308（slave）</h3>
<p>和前面的主库差不多，不过从库的配置文件变了</p>
<pre><code class="language-bash"> mkdir -p /docker/mysql/mysql-3308/conf
 mkdir -p /docker/mysql/mysql-3308/mysql-files
 mkdir -p /docker/mysql/mysql-3308/data
cd /docker/mysql/mysql-3308/conf
sudo touch my-3308.cnf
//mysql-3308.cnf
[mysqld]
user = mysql
character-set-server = utf8mb4
default_authentication_plugin = mysql_native_password

[client]
default-character-set = utf8mb4

[mysql]
default-character-set = utf8mb4

[mysqld]
port=3308

docker run -d -p 3308:3308 --privileged=true -v /docker/mysql/mysql-3308/conf/my-3308.cnf:/etc/mysql/my.cnf -v /docker/mysql/mysql-3308/data:/var/lib/mysql -v /docker/mysql/mysql-3308/mysql-files:/var/lib/mysql-files/ -e MYSQL_ROOT_PASSWORD=123456 --name mysql-3308 mysql:latest


</code></pre>
<p>我们使用<code>docker ps</code>来查看时候启动</p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1584197839-image-20200314225719550.png" alt="image-20200314225719550" loading="lazy"></figure>
<h3 id="配置master的slave访问用户">配置master的slave访问用户</h3>
<pre><code class="language-bash">//进入mysql-3307的docker命令行
sudo docker exec -it mysql-1 bash
mysql -uroot -p123456

mysql&gt; use mysql;
mysql&gt; select host, user, plugin from user;
+-----------+------------------+-----------------------+
| host      | user             | plugin                |
+-----------+------------------+-----------------------+
| %         | root             | mysql_native_password |
| localhost | mysql.infoschema | caching_sha2_password |
| localhost | mysql.session    | caching_sha2_password |
| localhost | mysql.sys        | caching_sha2_password |
| localhost | root             | mysql_native_password |
+-----------+------------------+-----------------------+
</code></pre>
<blockquote>
<p>这里有个地方要注意一下 mysql8.0默认的身份验证插件是 caching_sha2_password, 旧版的navicat不支持这种身份验证插件，可以修改为mysql_native_password<br>
在MySQL 5.7中，默认的身份验证插件是 mysql_native_password !<br>
( ALTER USER ‘root’@‘localhost’ IDENTIFIED WITH mysql_native_password BY ‘123456’; )</p>
</blockquote>
<p>由于我们在配置中预先设置了default_authentication_plugin = mysql_native_password<br>
所以默认root的密码加密是mysql_native_password</p>
<pre><code class="language-sql">//创建slave用户
mysql&gt; CREATE USER 'slave_1'@'%' IDENTIFIED BY '123456';
Query OK, 0 rows affected (0.13 sec)
//给新用户授权
mysql&gt; GRANT REPLICATION SLAVE ON *.* TO 'slave_1'@'%';
Query OK, 0 rows affected (0.31 sec)
//刷新权限
mysql&gt; FLUSH PRIVILEGES;
Query OK, 0 rows affected (0.02 sec)
</code></pre>
<h3 id="配置mysql-3307master的-my-3307cnf">配置mysql-3307(master)的 my-3307.cnf</h3>
<p>这边配置一下mysql-3307和mysql-3308的binlog设置 ，因为mysql实际是传输binlog(二进制日志)来达成复制的,具体的同步流程和原理可以百度一下</p>
<p>因为创建docker mysql的时候就把 /docker/mysql/mysql-3307/conf/my-3307.cnf 映射到了 /etc/mysql/my.cnf里,所以直接修改/docker/mysql/mysql-3307/conf/my-3307.cnf 再重启就完事了</p>
<pre><code class="language-bash">[mysqld]
user=mysql
character-set-server=utf8mb4
default_authentication_plugin=mysql_native_password
[client]
default-character-set=utf8mb4
[mysql]
default-character-set=utf8mb4
[mysqld]
port=3307

# 设备编号 不能与其他mysql相同
server-id = 1
# 开启 binlog
log-bin = mysql-bin
# 复制的数据库
binlog-do-db = test_school
# 不复制的数据库
binlog_ignore_db = mysql
# 从复制的格式（mixed,statement,row，默认格式是statement）
binlog-format = mixed
# 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。
expire_logs_days = 7  
</code></pre>
<p>重启一下mysql-3307(master)</p>
<pre><code class="language-sql">sudo docker restart mysql-1
sudo docker exec -it mysql-1 bash
mysql -uroot -p123456
mysql&gt; show master status;
+------------------+----------+--------------+-------------------------------------------------+-------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB                                | Executed_Gtid_Set |
+------------------+----------+--------------+-------------------------------------------------+-------------------+
| mysql-bin.000001 |      155 | test_school  | sys,mysql,information_schema,performance_schema |                   |
+------------------+----------+--------------+-------------------------------------------------+-------------------+
1 row in set (0.00 sec)
</code></pre>
<p>可以看到mysql-3306(master)binlog生效了</p>
<h3 id="配置mysql-3308slave的-mycnf">配置mysql-3308(slave)的 my.cnf</h3>
<p>同理修改mysql-3308(slave)的配置文件</p>
<pre><code class="language-bash">[mysqld]
user = mysql
character-set-server = utf8mb4
default_authentication_plugin = mysql_native_password

[client]
default-character-set = utf8mb4

[mysql]
default-character-set = utf8mb4

[mysqld]
port=3308

bind-address = 0.0.0.0

#skip-name-resolve

# 设备编号 不能与其他mysql相同
server-id = 2
# 开启 binlog 以备Slave作为其它Slave的Master时使用
log-bin = mysql-slave1-bin
# 复制的数据库
binlog-do-db = test_school
# 不复制的数据库
binlog_ignore_db = mysql
# 从复制的格式（mixed,statement,row，默认格式是statement）
binlog-format = mixed
# 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。
expire_logs_days = 7

</code></pre>
<p>配置mysql-3308(slave)的mysql同步信息</p>
<pre><code class="language-bash">sudo docker restart mysql-3308
sudo docker exec -it mysql-2 bash
mysql -uroot -p123456

//修改要同步的master的配置, 用之前在mysql-3308(master)创建的slave_1用户
mysql&gt; CHANGE MASTER TO
    -&gt; MASTER_HOST='*.*.*.*',
    -&gt; MASTER_USER='slave_1',
    -&gt; MASTER_PASSWORD='123456',
    -&gt; MASTER_PORT=33061,
    -&gt; MASTER_LOG_FILE='mysql-bin.000001',
    -&gt; MASTER_LOG_POS=155;
Query OK, 0 rows affected, 2 warnings (0.45 sec)
</code></pre>
<p>MASTER_LOG_FILE 就是master里的File, MASTER_LOG_POS就是master里的Position</p>
<h3 id="关于mster_host的指向问题">关于MSTER_HOST的指向问题</h3>
<p>这里是用docker做的主从复制，必须要是用外网IP才可以连接，内网IP或者localhost都是不行的！ 在docker里面用内网IP连不上另一个docker的mysql，必要要用外网IP，外网IP，外网IP！</p>
<h3 id="查看同步状态">查看同步状态</h3>
<p>先开启 slave</p>
<pre><code class="language-sql">mysql&gt; start slave;
Query OK, 0 rows affected (0.02 sec)

mysql&gt; show slave status 
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: *.*.*.*
                  Master_User: slave_1
                  Master_Port: 33061
                Connect_Retry: 60
              Master_Log_File: mysql-bin.000003
          Read_Master_Log_Pos: 155
               Relay_Log_File: 1675298fc92a-relay-bin.000004
                Relay_Log_Pos: 369
        Relay_Master_Log_File: mysql-bin.000003
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
            ...

1 row in set (0.00 sec)
</code></pre>
<p>看到 Slave_IO_Running, Slave_SQL_Running 都为YES的情况 就是主从复制设置成功了<br>
当然你也可以在主库表中插入一条数据，看看从库是否有同步</p>
<p>这里有可能存在的错误：</p>
<ul>
<li>
<p>网络不通</p>
</li>
<li>
<p>账号密码错误</p>
</li>
<li>
<p>master_log_file 或者 master_log_pos 错误</p>
</li>
<li>
<p>端口未开放（防火墙）</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[消息队列的使用]]></title>
        <id>https://Nobodylesszb.github.io/post/rabbitmq/</id>
        <link href="https://Nobodylesszb.github.io/post/rabbitmq/">
        </link>
        <updated>2020-03-11T07:39:02.000Z</updated>
        <content type="html"><![CDATA[<h3 id="爬虫生产者消费者模型">爬虫生产者消费者模型</h3>
<h4 id="为什么使用rabbitmq">为什么使用rabbitmq</h4>
<p>我们都知道消息队列主要作用就是<code>解耦，异步，削峰</code>，在处理爬虫的时候遇到下列这样的问题，</p>
<ul>
<li>有时候爬取网页时候。总有漏爬的信息。比如一块区域内商家的消息这样，爬虫突然中断，导致漏爬。对于漏爬是不可接受的，因为这是客户要求的，所以就必须先保存商家的id入库，等到真正采集到，再删除</li>
<li>对于突然中断的任务，如果采用之前的方式，是没有消息通知的，</li>
<li>我们可以允许消息多次消费，但是不能允许消息丢失</li>
<li>异步爬取。不必立即爬取信息</li>
</ul>
<p>综合考察，决定采用消息队列做消息容器</p>
<h4 id="如何保证rabbitmq的高可用">如何保证rabbitmq的高可用</h4>
<p>在设计爬虫生产者消费者模型的时候，高可用是必须要保证的，详情请看<a href="https://github.com/Nobodylesszb/ExcellentJava/blob/master/doc/system-design/data-communication/rabbitmq/rabbitmq%E9%AB%98%E5%8F%AF%E7%94%A8.md">rabbitmq高可用</a>)</p>
<p>这是我写的一篇关于rabbitmq如何高可用的文章</p>
<h4 id="如何保证消息不被重复消费">如何保证消息不被重复消费</h4>
<p>虽然在设计爬虫生产者消费者模型的时候对消息的重复性不是那么的关注，但是能不重复消费总是好的</p>
<h4 id="如何保证消息的可靠性传输-比如消息丢失问题">如何保证消息的可靠性传输。比如消息丢失问题</h4>
<p>数据的丢失问题，可能出现在生产者、MQ、消费者中，咱们从 RabbitMQ 和 Kafka 分别来分析一下吧。</p>
<h3 id="rabbitmq">RabbitMQ</h3>
<p>[<img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1583676539-rabbitmq-message-lose.png" alt="rabbitmq-message-lose" loading="lazy">]</p>
<h4 id="生产者弄丢了数据">生产者弄丢了数据</h4>
<p>生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，因为网络问题啥的，都有可能。</p>
<p>此时可以选择用 RabbitMQ 提供的事务功能，就是生产者<strong>发送数据之前</strong>开启 RabbitMQ 事务<code>channel.txSelect</code>，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务<code>channel.txRollback</code>，然后重试发送消息；如果收到了消息，那么可以提交事务<code>channel.txCommit</code>。</p>
<pre><code>// 开启事务
channel.txSelect
try {
    // 这里发送消息
} catch (Exception e) {
    channel.txRollback

    // 这里再次重发这条消息
}

// 提交事务
channel.txCommit
</code></pre>
<p>但是问题是，RabbitMQ 事务机制（同步）一搞，基本上<strong>吞吐量会下来，因为太耗性能</strong>。</p>
<p>所以一般来说，如果你要确保说写 RabbitMQ 的消息别丢，可以开启 <code>confirm</code> 模式，在生产者那里设置开启 <code>confirm</code> 模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个 <code>ack</code> 消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个 <code>nack</code> 接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。</p>
<p>事务机制和 <code>confirm</code> 机制最大的不同在于，<strong>事务机制是同步的</strong>，你提交一个事务之后会<strong>阻塞</strong>在那儿，但是 <code>confirm</code> 机制是<strong>异步</strong>的，你发送个消息之后就可以发送下一个消息，然后那个消息 RabbitMQ 接收了之后会异步回调你的一个接口通知你这个消息接收到了。</p>
<p>所以一般在生产者这块<strong>避免数据丢失</strong>，都是用 <code>confirm</code> 机制的。</p>
<h4 id="rabbitmq-弄丢了数据">RabbitMQ 弄丢了数据</h4>
<p>就是 RabbitMQ 自己弄丢了数据，这个你必须<strong>开启 RabbitMQ 的持久化</strong>，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，<strong>恢复之后会自动读取之前存储的数据</strong>，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，<strong>可能导致少量数据丢失</strong>，但是这个概率较小。</p>
<p>设置持久化有<strong>两个步骤</strong>：</p>
<ul>
<li>创建 queue 的时候将其设置为持久化<br>
这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。</li>
<li>第二个是发送消息的时候将消息的 <code>deliveryMode</code> 设置为 2<br>
就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。</li>
</ul>
<p>必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。</p>
<p>注意，哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。</p>
<p>所以，持久化可以跟生产者那边的 <code>confirm</code> 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 <code>ack</code> 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 <code>ack</code>，你也是可以自己重发的。</p>
<h4 id="消费端弄丢了数据">消费端弄丢了数据</h4>
<p>RabbitMQ 如果丢失了数据，主要是因为你消费的时候，<strong>刚消费到，还没处理，结果进程挂了</strong>，比如重启了，那么就尴尬了，RabbitMQ 认为你都消费了，这数据就丢了。</p>
<p>这个时候得用 RabbitMQ 提供的 <code>ack</code> 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 <code>ack</code>，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 <code>ack</code> 一把。这样的话，如果你还没处理完，不就没有 <code>ack</code> 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。</p>
<p>[<img src="https://gitee.com/nobodylesszb/upic/raw/pic/upload/pics/1583676540-rabbitmq-message-lose-solution.png" alt="rabbitmq-message-lose-solution" loading="lazy">]</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://Nobodylesszb.github.io/post/hello-gridea/</id>
        <link href="https://Nobodylesszb.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>